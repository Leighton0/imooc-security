## 2019-03-08

![2019-03-08_153304](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/notes/pictures/2019-03-08_153304.png)

springboot 的项目里面自带tomcat ，打包为jar包后，`java -jar demo.jar`也可以直接运行成功

maven 打包  package

## 2019-03-14

### 服务异常处理 

错误页面自定义，可以放在如图所示文件下。但是只在web端生效，APP端不生效

![2019-03-14_083353](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/notes/2019-03-14_083353.png)



#### 自定义异常

```java
 @GetMapping("{id:\\d+}")
    @JsonView(User.UserDetailView.class)
    public User getInfo(@PathVariable String id){

        throw new UserNotExistException(id);

     /*  *//* System.out.println("进入getInfo服务");
        User user=new User();*//*
        user.setUsername("tom");
        return user;*/
    }
```

在此处抛出`UserNotExistException`异常

```java
public class UserNotExistException extends RuntimeException{

    private String id;

    public UserNotExistException(String id) {
        this.id = id;
    }

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }
}

```

可被接收处理

```java
@ControllerAdvice
public class ControllerExceptionHandler {

    public Map<String,Object> handlerUserNotExistException(UserNotExistException ex){
        Map<String,Object> result=new HashMap<>();
        result.put("id",ex.getId());
        result.put("message",ex.getMessage());
        return result;
    }
}
```



![2019-03-14_085142](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/notes/2019-03-14_085142.png)

![2019-03-14_085157](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/notes/2019-03-14_085157.png)

自定义异常显示

![2019-03-14_085327](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/notes/2019-03-14_085327.png)

### 使用Filter和Interceptor拦截REST服务

```java
//@Component
public class TimeFilter implements Filter {

    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
        System.out.println("time filter init");
    }

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        System.out.println("time filter start");
        long start=new Date().getTime();
        filterChain.doFilter(servletRequest,servletResponse);
        System.out.println("time filter 耗时:"+(new Date().getTime()-start));
        System.out.println("time filter finish");
    }

    @Override
    public void destroy() {
        System.out.println("time filter destroy");
    }
}

```

过滤器，当是自己写的时候，加个```@Component```就可以了。但是如果使用第三方框架没法修改源码时,如下所示。写一个配置类即可。

```java
@Configuration
public class WebConfig extends WebMvcConfigurerAdapter {

    @Autowired
    private TimeInterceptor timeInterceptor;

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(timeInterceptor);
    }

    @Bean
    public FilterRegistrationBean timeFilter() {

        FilterRegistrationBean registrationBean = new FilterRegistrationBean();

        TimeFilter timeFilter = new TimeFilter();
        registrationBean.setFilter(timeFilter);

        List<String> urls = new ArrayList<>();
        urls.add("/*");
        registrationBean.setUrlPatterns(urls);

        return registrationBean;

    }

}

```

spring的拦截器如下所示，拦截器单纯的加```@Component```注解可不够，还要继承```WebMvcConfigurerAdapter```类，手动添加拦截器。自己写的过滤器却不需要，但拦截器比过滤器粒度更加细，得到更多的信息

```java
@Component
public class TimeInterceptor implements HandlerInterceptor {


    @Override
    public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object handler) throws Exception {
        System.out.println("preHandle");

        System.out.println(((HandlerMethod)handler).getBean().getClass().getName());
        System.out.println(((HandlerMethod)handler).getMethod().getName());

        httpServletRequest.setAttribute("startTime",new Date().getTime());
        return true;
    }

    @Override
    public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception {
        System.out.println("postHandle");
        Long start=(Long)httpServletRequest.getAttribute("startTime");
        System.out.println("time interceptor 耗时:"+(new Date().getTime()-start));
    }

    @Override
    public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception ex) throws Exception {
        System.out.println("afterCompletion");
        Long start = (Long) httpServletRequest.getAttribute("startTime");
        System.out.println("time interceptor 耗时:"+ (new Date().getTime() - start));
        System.out.println("ex is "+ex);
    }
}
```

运行结果如下所示：

![2019-03-14_164310](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/notes/2019-03-14_164310.png)

```
time filter start
preHandle
com.imooc.web.controller.UserController
getInfo
进入getInfo服务
postHandle
time interceptor 耗时:35
afterCompletion
time interceptor 耗时:35
ex is null
time filter 耗时:57
time filter finish
```

## 2019年3月15日

### 使用切片拦截REST服务
![2019-03-14_165856](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/notes/2019-03-14_165856.png)

```java
@Aspect
@Component
public class TimeAspect {

    //执行 任何返回值  此类  任何方法 任何参数
    @Around("execution(* com.imooc.web.controller.UserController.*(..))")
    public Object handleControllerMethod(ProceedingJoinPoint proceedingJoinPoint)throws Throwable{
        System.out.println("time aspect start");

        Object[] args=proceedingJoinPoint.getArgs();
        for (Object arg:args){
            System.out.println("arg is "+arg);
        }

        long start=new Date().getTime();

        Object object=proceedingJoinPoint.proceed();

        System.out.println("time aspect 耗时:"+(new Date().getTime()-start));

        System.out.println("time aspect end");

        return object;
    }
}
```

```xml
 <!--Aspect 切面拦截-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-aop</artifactId>
        </dependency>
```

运行之后控制台

```
time filter start
preHandle
com.imooc.web.controller.UserController$$EnhancerBySpringCGLIB$$dbe78642
getInfo
time aspect start
arg is 1
进入getInfo服务
time aspect 耗时:3
time aspect end
postHandle
time interceptor 耗时:50
afterCompletion
time interceptor 耗时:50
ex is null
time filter 耗时:55
time filter finish
```

### 运行顺序总结

![2019-03-14_215327](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/notes/2019-03-14_215327.png)

### 文件上传与下载 

```java
@RestController
@RequestMapping("/file")
public class FileController {

    private String folder = "D:\\aacode\\java\\imooc\\imooc-security\\imooc-security-demo\\src\\main\\java\\com\\imooc\\web\\controller";

    @PostMapping
    public FileInfo upload(MultipartFile file)throws Exception{

        System.out.println("public FileInfo upload(MultipartFile file)方法");
        System.out.println(file.getName());
        System.out.println(file.getOriginalFilename());
        System.out.println(file.getSize());

        File localFile=new File(folder,new Date().getTime()+".txt");
        file.transferTo(localFile);

        return new FileInfo(localFile.getAbsolutePath());
    }

    @GetMapping("/{id}")
    public void download(@PathVariable String id, HttpServletRequest request, HttpServletResponse response)throws Exception{

        //写在小括号里面，IO流会自己关闭，省去累赘代码
        try (InputStream inputStream=new FileInputStream(new File(folder,id+".txt"));
             OutputStream outputStream=response.getOutputStream()){

            response.setContentType("application/x-download");
            response.addHeader("Content-Disposition","attachment;filename=test.txt");

            IOUtils.copy(inputStream,outputStream);
            outputStream.flush();
        }
    }

}
```

```java
@Data
@AllArgsConstructor
@NoArgsConstructor
public class FileInfo {

    private String path;
}
```

```java
@Test
public void whenUploadSuccess()throws Exception{
    String result=mockMvc.perform(fileUpload("/file")
        .file(new MockMultipartFile("file","test.txt","mutipart/form-data","hello upload".getBytes("UTF-8"))))
            .andExpect(status().isOk())
            .andReturn().getResponse().getContentAsString();
    System.out.println(result);
}
```

### 使用多线程提高REST服务性能

![2019-03-15_142428](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/notes/2019-03-15_142428.png)

![2019-03-15_143954](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/notes/2019-03-15_143954.png)

#### Runnable异步处理

首先关闭注解Timeaspect类   webconfig类的一个bean，一个addInterceptor，免得控制台信息太多

```java
package com.imooc.web.async;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.concurrent.Callable;

/**
 * @Description
 * @auther 断弯刀
 * @create 2019-03-15 17:04
 */
@RestController
public class AsyncController {

    private Logger logger= LoggerFactory.getLogger(getClass());

    @RequestMapping("/order")
    public Callable<String> order()throws Exception{
        logger.info("主线程开始");

        Callable<String> result=new Callable<String>() {
            @Override
            public String call() throws Exception {
                logger.info("子线程开始");
                Thread.sleep(1000);
                logger.info("子线程返回");
                return "success";
            }
        };

        logger.info("主线程返回");
        return result;
    }
}
```

浏览器测试

![2019-03-15_171943](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/notes/2019-03-15_171943.png)

控制台信息

```java
2019-03-15 17:14:19.146  INFO 13944 --- [nio-8080-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring FrameworkServlet 'dispatcherServlet'
2019-03-15 17:14:19.146  INFO 13944 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : FrameworkServlet 'dispatcherServlet': initialization started
2019-03-15 17:14:19.180  INFO 13944 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : FrameworkServlet 'dispatcherServlet': initialization completed in 34 ms
2019-03-15 17:14:19.218  INFO 13944 --- [nio-8080-exec-1] com.imooc.web.async.AsyncController      : 主线程开始
2019-03-15 17:14:19.219  INFO 13944 --- [nio-8080-exec-1] com.imooc.web.async.AsyncController      : 主线程返回
2019-03-15 17:14:19.226  INFO 13944 --- [      MvcAsync1] com.imooc.web.async.AsyncController      : 子线程开始
2019-03-15 17:14:20.228  INFO 13944 --- [      MvcAsync1] com.imooc.web.async.AsyncController      : 子线程返回
```

主线程开始后立马结束，副线程运行不影响主线程。意味着让主线程（即Tomcat的线程）去处理其它的HTTP请求。
意味着用这种方式写代码会对服务器的吞吐量有很大的提升。如上所示

#### DeferredResult异步处理

![2019-03-15_143721](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/notes/2019-03-15_143721.png)

```java
@Component
@Data
public class DeferredResultHolder {

    //key可以理解为每个订单号，每个订单号对应着订单的处理结果DeferredResult<String>
    private Map<String, DeferredResult<String>> map=new HashMap<>();

}
```

```java
@Component
@Slf4j
@Data
public class MockQueue {

    private String placeOrder;

    private String completeOrder;

    public void setPlaceOrder(String placeOrder)throws Exception{
        new Thread(() -> {
            log.info("接到下单请求: " + placeOrder);
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            this.completeOrder=placeOrder;
            log.info("下单请求处理完毕: " + placeOrder);
        }).start();

    }

}
```

```java
@Component
@Slf4j
//ContextRefreshedEvent整个spring完全初始化完毕的事件
public class QueueListener implements ApplicationListener<ContextRefreshedEvent> {

    @Autowired
    private MockQueue mockQueue;

    @Autowired
    private DeferredResultHolder deferredResultHolder;

    @Override
    public void onApplicationEvent(ContextRefreshedEvent contextRefreshedEvent) {

        //无限的while循环，要是不单开线程的话，就会阻塞整个系统的启动
        new Thread(() -> {
            while (true){
                if (StringUtils.isNotBlank(mockQueue.getCompleteOrder())){
                    String orderNumber=mockQueue.getCompleteOrder();
                    log.info("返回订单处理结果:"+orderNumber);
                    //setResult()中为最终要返回的信息
                    deferredResultHolder.getMap().get(orderNumber).setResult("place order success");
                    mockQueue.setCompleteOrder(null);
                }else {
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        }).start();
    }

}
```

```java
@RestController
@Slf4j
public class AsyncController {

    @Autowired
    private MockQueue mockQueue;

    @Autowired
    private DeferredResultHolder deferredResultHolder;

    @RequestMapping("/order")
    public DeferredResult<String> order()throws Exception{
        log.info("主线程开始");

        //8倍的随机数（相当于订单号），放入消息队列中
        String orderNumber = RandomStringUtils.randomNumeric(8);
        mockQueue.setPlaceOrder(orderNumber);

        DeferredResult<String> result = new DeferredResult<>();
        deferredResultHolder.getMap().put(orderNumber, result);

        log.info("主线程结束");
        return result;

    }
}
```

浏览器输入和返回结果

![2019-03-16_112625](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/notes/2019-03-16_112625.png)

控制台信息

```java
2019-03-16 11:21:03.517  INFO 8200 --- [nio-8080-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring FrameworkServlet 'dispatcherServlet'
2019-03-16 11:21:03.517  INFO 8200 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : FrameworkServlet 'dispatcherServlet': initialization started
2019-03-16 11:21:03.554  INFO 8200 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : FrameworkServlet 'dispatcherServlet': initialization completed in 36 ms
2019-03-16 11:21:03.590  INFO 8200 --- [nio-8080-exec-1] com.imooc.web.async.AsyncController      : 主线程开始
2019-03-16 11:21:03.592  INFO 8200 --- [nio-8080-exec-1] com.imooc.web.async.AsyncController      : 主线程结束
2019-03-16 11:21:03.592  INFO 8200 --- [      Thread-45] com.imooc.web.async.MockQueue            : 接到下单请求: 09583296
2019-03-16 11:21:04.592  INFO 8200 --- [      Thread-45] com.imooc.web.async.MockQueue            : 下单请求处理完毕: 09583296
2019-03-16 11:21:04.689  INFO 8200 --- [      Thread-33] com.imooc.web.async.QueueListener        : 返回订单处理结果:09583296
```

3个线程，模拟了3个服务器

实际上有3个线程，一个是主线程接收HTTP请求，一个线程来处理真正的下单逻辑，另外一个线程把第二个线程的处理结果返回给前台。
线程1和线程3之间用DeferredResult来进行信息的交互。3个线程隔离，互相之间通过消息队列来通讯

## 2019年3月16日

### 使用Swagger自动生成文档

```xml
 <!--生成文档-->
        <dependency>
            <groupId>io.springfox</groupId>
            <artifactId>springfox-swagger2</artifactId>
            <version>2.7.0</version>
        </dependency>
        <!--生成可视化界面-->
        <dependency>
            <groupId>io.springfox</groupId>
            <artifactId>springfox-swagger-ui</artifactId>
            <version>2.7.0</version>
        </dependency>
```

类上加注解```@EnableSwagger2```

片段例子

```java
@EnableSwagger2
public class DemoApplication { 
    
 @ApiOperation(value = "用户查询服务")
	public List<User> query(UserQueryCondition condition,
			@PageableDefault(page = 2, size = 17, sort = "username,asc") Pageable pageable) {
        
 @ApiModelProperty(value = "用户年龄起始值")
	private int age;
	@ApiModelProperty(value = "用户年龄终止值")
	private int ageTo;

public User getInfo(@ApiParam("用户id") @PathVariable String id){
```

### 使用WireMock伪造REST服务