![2019-03-08_153304](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/docs/pictures/2019-03-08_153304.png)

springboot 的项目里面自带tomcat ，打包为jar包后，`java -jar demo.jar`也可以直接运行成功

maven 打包  package

### 服务异常处理 

错误页面自定义，可以放在如图所示文件下。但是只在web端生效，APP端不生效

![2019-03-14_083353](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/docs/pictures/2019-03-14_083353.png)



#### 自定义异常

```java
 @GetMapping("{id:\\d+}")
    @JsonView(User.UserDetailView.class)
    public User getInfo(@PathVariable String id){

        throw new UserNotExistException(id);

     /*  *//* System.out.println("进入getInfo服务");
        User user=new User();*//*
        user.setUsername("tom");
        return user;*/
    }
```

在此处抛出`UserNotExistException`异常

```java
public class UserNotExistException extends RuntimeException{

    private String id;

    public UserNotExistException(String id) {
        this.id = id;
    }

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }
}

```

可被接收处理

```java
@ControllerAdvice
public class ControllerExceptionHandler {

    public Map<String,Object> handlerUserNotExistException(UserNotExistException ex){
        Map<String,Object> result=new HashMap<>();
        result.put("id",ex.getId());
        result.put("message",ex.getMessage());
        return result;
    }
}
```



![2019-03-14_085142](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/docs/pictures/2019-03-14_085142.png)

![2019-03-14_085157](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/docs/pictures/2019-03-14_085157.png)

自定义异常显示

![2019-03-14_085327](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/docs/pictures/2019-03-14_085327.png)

### 使用Filter和Interceptor拦截REST服务

```java
//@Component
public class TimeFilter implements Filter {

    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
        System.out.println("time filter init");
    }

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        System.out.println("time filter start");
        long start=new Date().getTime();
        filterChain.doFilter(servletRequest,servletResponse);
        System.out.println("time filter 耗时:"+(new Date().getTime()-start));
        System.out.println("time filter finish");
    }

    @Override
    public void destroy() {
        System.out.println("time filter destroy");
    }
}

```

过滤器，当是自己写的时候，加个```@Component```就可以了。但是如果使用第三方框架没法修改源码时,如下所示。写一个配置类即可。

```java
@Configuration
public class WebConfig extends WebMvcConfigurerAdapter {

    @Autowired
    private TimeInterceptor timeInterceptor;

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(timeInterceptor);
    }

    @Bean
    public FilterRegistrationBean timeFilter() {

        FilterRegistrationBean registrationBean = new FilterRegistrationBean();

        TimeFilter timeFilter = new TimeFilter();
        registrationBean.setFilter(timeFilter);

        List<String> urls = new ArrayList<>();
        urls.add("/*");
        registrationBean.setUrlPatterns(urls);

        return registrationBean;

    }

}

```

spring的拦截器如下所示，拦截器单纯的加```@Component```注解可不够，还要继承```WebMvcConfigurerAdapter```类，手动添加拦截器。自己写的过滤器却不需要，但拦截器比过滤器粒度更加细，得到更多的信息

```java
@Component
public class TimeInterceptor implements HandlerInterceptor {


    @Override
    public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object handler) throws Exception {
        System.out.println("preHandle");

        System.out.println(((HandlerMethod)handler).getBean().getClass().getName());
        System.out.println(((HandlerMethod)handler).getMethod().getName());

        httpServletRequest.setAttribute("startTime",new Date().getTime());
        return true;
    }

    @Override
    public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception {
        System.out.println("postHandle");
        Long start=(Long)httpServletRequest.getAttribute("startTime");
        System.out.println("time interceptor 耗时:"+(new Date().getTime()-start));
    }

    @Override
    public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception ex) throws Exception {
        System.out.println("afterCompletion");
        Long start = (Long) httpServletRequest.getAttribute("startTime");
        System.out.println("time interceptor 耗时:"+ (new Date().getTime() - start));
        System.out.println("ex is "+ex);
    }
}
```

运行结果如下所示：

![2019-03-14_164310](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/docs/pictures/2019-03-14_164310.png)

```
time filter start
preHandle
com.imooc.web.controller.UserController
getInfo
进入getInfo服务
postHandle
time interceptor 耗时:35
afterCompletion
time interceptor 耗时:35
ex is null
time filter 耗时:57
time filter finish
```

### 使用切片拦截REST服务
![2019-03-14_165856](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/docs/pictures/2019-03-14_165856.png)

```java
@Aspect
@Component
public class TimeAspect {

    //执行 任何返回值  此类  任何方法 任何参数
    @Around("execution(* com.imooc.web.controller.UserController.*(..))")
    public Object handleControllerMethod(ProceedingJoinPoint proceedingJoinPoint)throws Throwable{
        System.out.println("time aspect start");

        Object[] args=proceedingJoinPoint.getArgs();
        for (Object arg:args){
            System.out.println("arg is "+arg);
        }

        long start=new Date().getTime();

        Object object=proceedingJoinPoint.proceed();

        System.out.println("time aspect 耗时:"+(new Date().getTime()-start));

        System.out.println("time aspect end");

        return object;
    }
}
```

```xml
 <!--Aspect 切面拦截-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-aop</artifactId>
        </dependency>
```

运行之后控制台

```
time filter start
preHandle
com.imooc.web.controller.UserController$$EnhancerBySpringCGLIB$$dbe78642
getInfo
time aspect start
arg is 1
进入getInfo服务
time aspect 耗时:3
time aspect end
postHandle
time interceptor 耗时:50
afterCompletion
time interceptor 耗时:50
ex is null
time filter 耗时:55
time filter finish
```

### 运行顺序总结

![2019-03-14_215327](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/docs/pictures/2019-03-14_215327.png)

### 文件上传与下载 

```java
@RestController
@RequestMapping("/file")
public class FileController {

    private String folder = "D:\\aacode\\java\\imooc\\imooc-security\\imooc-security-demo\\src\\main\\java\\com\\imooc\\web\\controller";

    @PostMapping
    public FileInfo upload(MultipartFile file)throws Exception{

        System.out.println("public FileInfo upload(MultipartFile file)方法");
        System.out.println(file.getName());
        System.out.println(file.getOriginalFilename());
        System.out.println(file.getSize());

        File localFile=new File(folder,new Date().getTime()+".txt");
        file.transferTo(localFile);

        return new FileInfo(localFile.getAbsolutePath());
    }

    @GetMapping("/{id}")
    public void download(@PathVariable String id, HttpServletRequest request, HttpServletResponse response)throws Exception{

        //写在小括号里面，IO流会自己关闭，省去累赘代码
        try (InputStream inputStream=new FileInputStream(new File(folder,id+".txt"));
             OutputStream outputStream=response.getOutputStream()){

            response.setContentType("application/x-download");
            response.addHeader("Content-Disposition","attachment;filename=test.txt");

            IOUtils.copy(inputStream,outputStream);
            outputStream.flush();
        }
    }

}
```

```java
@Data
@AllArgsConstructor
@NoArgsConstructor
public class FileInfo {

    private String path;
}
```

```java
@Test
public void whenUploadSuccess()throws Exception{
    String result=mockMvc.perform(fileUpload("/file")
        .file(new MockMultipartFile("file","test.txt","mutipart/form-data","hello upload".getBytes("UTF-8"))))
            .andExpect(status().isOk())
            .andReturn().getResponse().getContentAsString();
    System.out.println(result);
}
```

### 使用多线程提高REST服务性能

![2019-03-15_142428](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/docs/pictures/2019-03-15_142428.png)

![2019-03-15_143954](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/docs/pictures/2019-03-15_143954.png)

#### Runnable异步处理

首先关闭注解Timeaspect类   webconfig类的一个bean，一个addInterceptor，免得控制台信息太多

```java
package com.imooc.web.async;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.concurrent.Callable;

/**
 * @Description
 * @auther 断弯刀
 * @create 2019-03-15 17:04
 */
@RestController
public class AsyncController {

    private Logger logger= LoggerFactory.getLogger(getClass());

    @RequestMapping("/order")
    public Callable<String> order()throws Exception{
        logger.info("主线程开始");

        Callable<String> result=new Callable<String>() {
            @Override
            public String call() throws Exception {
                logger.info("子线程开始");
                Thread.sleep(1000);
                logger.info("子线程返回");
                return "success";
            }
        };

        logger.info("主线程返回");
        return result;
    }
}
```

浏览器测试

![2019-03-15_171943](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/docs/pictures/2019-03-15_171943.png)

控制台信息

```java
2019-03-15 17:14:19.146  INFO 13944 --- [nio-8080-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring FrameworkServlet 'dispatcherServlet'
2019-03-15 17:14:19.146  INFO 13944 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : FrameworkServlet 'dispatcherServlet': initialization started
2019-03-15 17:14:19.180  INFO 13944 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : FrameworkServlet 'dispatcherServlet': initialization completed in 34 ms
2019-03-15 17:14:19.218  INFO 13944 --- [nio-8080-exec-1] com.imooc.web.async.AsyncController      : 主线程开始
2019-03-15 17:14:19.219  INFO 13944 --- [nio-8080-exec-1] com.imooc.web.async.AsyncController      : 主线程返回
2019-03-15 17:14:19.226  INFO 13944 --- [      MvcAsync1] com.imooc.web.async.AsyncController      : 子线程开始
2019-03-15 17:14:20.228  INFO 13944 --- [      MvcAsync1] com.imooc.web.async.AsyncController      : 子线程返回
```

主线程开始后立马结束，副线程运行不影响主线程。意味着让主线程（即Tomcat的线程）去处理其它的HTTP请求。
意味着用这种方式写代码会对服务器的吞吐量有很大的提升。如上所示

#### DeferredResult异步处理

![2019-03-15_143721](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/docs/pictures/2019-03-15_143721.png)

```java
@Component
@Data
public class DeferredResultHolder {

    //key可以理解为每个订单号，每个订单号对应着订单的处理结果DeferredResult<String>
    private Map<String, DeferredResult<String>> map=new HashMap<>();

}
```

```java
@Component
@Slf4j
@Data
public class MockQueue {

    private String placeOrder;

    private String completeOrder;

    public void setPlaceOrder(String placeOrder)throws Exception{
        new Thread(() -> {
            log.info("接到下单请求: " + placeOrder);
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            this.completeOrder=placeOrder;
            log.info("下单请求处理完毕: " + placeOrder);
        }).start();

    }

}
```

```java
@Component
@Slf4j
//ContextRefreshedEvent整个spring完全初始化完毕的事件
public class QueueListener implements ApplicationListener<ContextRefreshedEvent> {

    @Autowired
    private MockQueue mockQueue;

    @Autowired
    private DeferredResultHolder deferredResultHolder;

    @Override
    public void onApplicationEvent(ContextRefreshedEvent contextRefreshedEvent) {

        //无限的while循环，要是不单开线程的话，就会阻塞整个系统的启动
        new Thread(() -> {
            while (true){
                if (StringUtils.isNotBlank(mockQueue.getCompleteOrder())){
                    String orderNumber=mockQueue.getCompleteOrder();
                    log.info("返回订单处理结果:"+orderNumber);
                    //setResult()中为最终要返回的信息
                    deferredResultHolder.getMap().get(orderNumber).setResult("place order success");
                    mockQueue.setCompleteOrder(null);
                }else {
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        }).start();
    }

}
```

```java
@RestController
@Slf4j
public class AsyncController {

    @Autowired
    private MockQueue mockQueue;

    @Autowired
    private DeferredResultHolder deferredResultHolder;

    @RequestMapping("/order")
    public DeferredResult<String> order()throws Exception{
        log.info("主线程开始");

        //8倍的随机数（相当于订单号），放入消息队列中
        String orderNumber = RandomStringUtils.randomNumeric(8);
        mockQueue.setPlaceOrder(orderNumber);

        DeferredResult<String> result = new DeferredResult<>();
        deferredResultHolder.getMap().put(orderNumber, result);

        log.info("主线程结束");
        return result;

    }
}
```

浏览器输入和返回结果

![2019-03-16_112625](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/docs/pictures/2019-03-16_112625.png)

控制台信息

```java
2019-03-16 11:21:03.517  INFO 8200 --- [nio-8080-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring FrameworkServlet 'dispatcherServlet'
2019-03-16 11:21:03.517  INFO 8200 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : FrameworkServlet 'dispatcherServlet': initialization started
2019-03-16 11:21:03.554  INFO 8200 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : FrameworkServlet 'dispatcherServlet': initialization completed in 36 ms
2019-03-16 11:21:03.590  INFO 8200 --- [nio-8080-exec-1] com.imooc.web.async.AsyncController      : 主线程开始
2019-03-16 11:21:03.592  INFO 8200 --- [nio-8080-exec-1] com.imooc.web.async.AsyncController      : 主线程结束
2019-03-16 11:21:03.592  INFO 8200 --- [      Thread-45] com.imooc.web.async.MockQueue            : 接到下单请求: 09583296
2019-03-16 11:21:04.592  INFO 8200 --- [      Thread-45] com.imooc.web.async.MockQueue            : 下单请求处理完毕: 09583296
2019-03-16 11:21:04.689  INFO 8200 --- [      Thread-33] com.imooc.web.async.QueueListener        : 返回订单处理结果:09583296
```

3个线程，模拟了3个服务器

实际上有3个线程，一个是主线程接收HTTP请求，一个线程来处理真正的下单逻辑，另外一个线程把第二个线程的处理结果返回给前台。
线程1和线程3之间用DeferredResult来进行信息的交互。3个线程隔离，互相之间通过消息队列来通讯

### 使用Swagger自动生成文档

```xml
 <!--生成文档-->
        <dependency>
            <groupId>io.springfox</groupId>
            <artifactId>springfox-swagger2</artifactId>
            <version>2.7.0</version>
        </dependency>
        <!--生成可视化界面-->
        <dependency>
            <groupId>io.springfox</groupId>
            <artifactId>springfox-swagger-ui</artifactId>
            <version>2.7.0</version>
        </dependency>
```

类上加注解```@EnableSwagger2```

片段例子

```java
@EnableSwagger2
public class DemoApplication { 
    
 @ApiOperation(value = "用户查询服务")
	public List<User> query(UserQueryCondition condition,
			@PageableDefault(page = 2, size = 17, sort = "username,asc") Pageable pageable) {
        
 @ApiModelProperty(value = "用户年龄起始值")
	private int age;
	@ApiModelProperty(value = "用户年龄终止值")
	private int ageTo;

public User getInfo(@ApiParam("用户id") @PathVariable String id){
```

### 使用WireMock伪造REST服务

### SpringSecurity基本原理

![2019-03-16_161107](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/docs/pictures/2019-03-16_161107.png)

### 自定义用户认证逻辑

![2019-03-18_085640](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/docs/pictures/2019-03-18_091525.png)

application.properties    默认安全认证即打开

```properties
# security.basic.enabled = true
```

浏览器进入

![2019-03-19_155529](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/docs/pictures/2019-03-19_155529.png)

修改配置，改为表单登录

```java
@Configuration
public class BrowserSecurityConfig extends WebSecurityConfigurerAdapter {

    //注入密码加密的类
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new SCryptPasswordEncoder();
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.formLogin()
            .and()
            .authorizeRequests()
            .anyRequest()    //任何请求
            .authenticated();   //都需要认证
    }
}

```

```java
@Slf4j
@Component
public class MyUserDetailsService implements UserDetailsService {

    @Autowired
    private PasswordEncoder passwordEncoder;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        log.info("用户名："+username);
        //指定用户授权登录信息
        //密码加密，使用的是盐值加密
        String password = passwordEncoder.encode("123456");
        log.info("数据库中密码是："+password);
        //User类是Spring内置的一个类，实现了UserDetails接口，而这个接口是UserDetailSerice的子接口
        return new User(username, password, true, true, true, true
                , AuthorityUtils.commaSeparatedStringToAuthorityList("admin"));
    }

}
```

![2019-03-19_163456](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/docs/pictures/2019-03-19_163456.png)

控制台信息

```
2019-03-19 16:32:00.172  INFO 10532 --- [nio-8080-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring FrameworkServlet 'dispatcherServlet'
2019-03-19 16:32:00.172  INFO 10532 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : FrameworkServlet 'dispatcherServlet': initialization started
2019-03-19 16:32:00.209  INFO 10532 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : FrameworkServlet 'dispatcherServlet': initialization completed in 37 ms
2019-03-19 16:32:13.766  INFO 10532 --- [nio-8080-exec-4] c.i.s.browser.MyUserDetailsService       : 用户名：zjx
2019-03-19 16:32:13.882  INFO 10532 --- [nio-8080-exec-4] c.i.s.browser.MyUserDetailsService       : 数据库中密码是：$e0801$GYPznAhqFHKSas4OpdjmGZ1w1PTT6oQXlTnpjQEc9+gcWb6LdeB69iGFzZF+8Dftt0tGNro1AOG63E61LSN4Yw==$zHyK7F/nnUnhp2mtDJIeNun2lyqU13LylTFw7YNDhBw=
```

### 个性化用户认证流程

![2019-03-19_143943](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/docs/pictures/2019-03-19_143943.png)

#### 自定义登录界面

​	注意loginPage和antMatchers放行登录页面，不然会一直重定向。还需注意的是登录页面内部先不要填写引用的超链接，不然还是会被拦截，会被跳转到404页面

```java
@Override
    protected void configure(HttpSecurity http) throws Exception {
        http.formLogin() //认证
            .loginPage("/imooc-signIn.html")  //设置登录页面
                .loginProcessingUrl("/authentication/form") //遇到该请求则进行user password认证
            .and()
                .authorizeRequests()   //授权
                 //当访问这个路径的时候不需要身份认证 除了它其他的是需要身份认证
                .antMatchers("/imooc-signIn.html").permitAll()
                .anyRequest()    //任何请求
                .authenticated()   //都需要认证
            .and()
                .csrf().disable();

    }
```
目录结构

![2019-03-19_172900](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/docs/pictures/2019-03-19_172900.png)

![2019-03-18_092533](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/docs/pictures/2019-03-18_092533.png)

系统配置封装

浏览器安全相关配置项、验证码相关配置项、等等

![2019-03-18_093712](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/docs/pictures/2019-03-18_093712.png)

将登录路径改为 /authentication/require，再写controller控制处理

```java
@Configuration
@Slf4j
public class BrowserSecurityConfig extends WebSecurityConfigurerAdapter {

    @Autowired
    private SecurityProperties securityProperties;

    //注入密码加密的类
    @Bean
    public PasswordEncoder passwordEncoder() {
        //这里如果是自己编写的加密 则调用自己的类 方法有编码和解码验证方法
        return new SCryptPasswordEncoder();
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
      
        http.formLogin() //认证
            .loginPage("/authentication/require")  //设置登录页面
                .loginProcessingUrl("/authentication/form") //遇到该请求则进行user password认证
            .and()
                .authorizeRequests()   //授权
                //当访问这个路径的时候不需要身份认证 除了它其他的是需要身份认证
                .antMatchers("/authentication/require", securityProperties.getBrowser().getLoginPage()).permitAll()
                .anyRequest()    //任何请求
                .authenticated()   //都需要认证
            .and()
                .csrf().disable();

    }
}
```

controller控制处理，如果是 .html 后缀来的，重定向到登录页面去。否则返回json信息

```java
@RestController
@Slf4j
public class BrowserSecurityController {

    private RequestCache requestCache = new HttpSessionRequestCache();

    private RedirectStrategy redirectStrategy = new DefaultRedirectStrategy();

    @Autowired
    private SecurityProperties securityProperties;

    /**
     * 当需要身份验证时跳转到这里
     * @param request
     * @param response
     * @return
     * @throws Exception
     */
    @RequestMapping("/authentication/require")
    @ResponseStatus(code = HttpStatus.UNAUTHORIZED)   //返回401状态码
    public SimpleResponse requireAuthentication(HttpServletRequest request, HttpServletResponse response)throws Exception {

        //保存的之前的请求(引发跳转的请求)拿出来
        SavedRequest savedRequest = requestCache.getRequest(request, response);
        if (savedRequest != null) {
            //引发跳转的url
            String targetUrl=savedRequest.getRedirectUrl();
            log.info("引发跳转的请求是:"+targetUrl);
            if (StringUtils.endsWithIgnoreCase(targetUrl, "html")) {
                redirectStrategy.sendRedirect(request, response, securityProperties.getBrowser().getLoginPage());
                log.info("BrowserSecurityController==>securityProperties.getBrowser().getLoginPage()=="+securityProperties.getBrowser().getLoginPage());
            }
        }
        return new SimpleResponse("访问的服务需要身份认证,请引导用户到登录页");
    }
}
```

```java
@Data
@AllArgsConstructor
public class SimpleResponse {

    private Object content;

}
```

系统配置不管是在浏览器还是在APP模块都会被用到，所以写到core模块中。

SecurityProperties

```java
//意思是这个类会读取配置文件中所有以imooc.security开头的配置项
//其中browser的配置项会读取到BrowserProperties的对象中去
@ConfigurationProperties(prefix = "imooc.security")
@Component
@Data
public class SecurityProperties {

    private BrowserProperties browser = new BrowserProperties();
}
```
EnableConfigurationProperties让ConfigurationProperties标注的注解生效

```java
@Configuration
@EnableConfigurationProperties(SecurityProperties.class)
//让BrowserProperties生效
public class SecurityCoreConfig {
}
```

图中对应关系

![2019-03-19_220530](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/docs/pictures/2019-03-19_220530.png)

```java
@Data
public class BrowserProperties {

    //设定默认值如果没有指定loginPage则访问该页面
    private String loginPage="/imooc-signIn.html";

}
```

#### 自定义登陆成功、失败处理

成功处理器

```java
@Component("imoocAuthenticationSuccessHandler")
@Slf4j
public class ImoocAuthenticationSuccessHandler extends SavedRequestAwareAuthenticationSuccessHandler {

    //启动的时候springmvc会注册一个mapper
    @Autowired
    private ObjectMapper objectMapper;

    @Autowired
    private SecurityProperties securityProperties;

    @Override
    public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws ServletException, IOException {
       log.info("登录成功");

        if (LoginResponseType.JSON.equals(securityProperties.getBrowser().getLoginType())) {
            response.setContentType("application/json;charset=utf-8");
            response.getWriter().write(objectMapper.writeValueAsString(authentication));
        } else {
            super.onAuthenticationSuccess(request, response, authentication);
        }
    }
}

```
失败处理器

```
@Component("imoocAuthenticationFailureHandler")
@Slf4j
public class ImoocAuthenticationFailureHandler extends SimpleUrlAuthenticationFailureHandler {

    @Autowired
    private ObjectMapper objectMapper;

    @Autowired
    private SecurityProperties securityProperties;

    @Override
    public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException {
       log.info("登录失败");

        if (LoginResponseType.JSON.equals(securityProperties.getBrowser().getLoginType())) {
            response.setStatus(HttpStatus.INTERNAL_SERVER_ERROR.value());
            response.setContentType("application/json;charset=utf-8");
            response.getWriter().write(objectMapper.writeValueAsString(new SimpleResponse(exception.getMessage())));
        } else {
            super.onAuthenticationFailure(request, response, exception);
        }
    }
}
```

```java
public enum LoginResponseType {

    /**
     * 跳转
     */
    REDIRECT,

    /**
     * 返回json
     */
    JSON
}
```
注意变量名一定要和application.properties中的名字一一对应，否则找不到不生效

```java
@Data
public class BrowserProperties {

    //设定默认值如果没有指定loginPage则访问该页面
    private String loginPage = "/imooc-signIn.html";

    private LoginResponseType loginType = LoginResponseType.JSON;  //默认返回json

}
```

```pro
imooc.security.browser.loginType = REDIRECT
```

最后注入使其生效

```java
@Configuration
@Slf4j
public class BrowserSecurityConfig extends WebSecurityConfigurerAdapter {

    @Autowired
    private SecurityProperties securityProperties;

    //让系统使用我们自定义 而不是系统默认的配置
    @Autowired
    private ImoocAuthenticationSuccessHandler imoocAuthenticationSuccessHandler;

    @Autowired
    private ImoocAuthenticationFailureHandler imoocAuthenticationFailureHandler;

    //注入密码加密的类
    @Bean
    public PasswordEncoder passwordEncoder() {
        //这里如果是自己编写的加密 则调用自己的类 方法有编码和解码验证方法
        return new SCryptPasswordEncoder();
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.formLogin() //认证
            .loginPage("/authentication/require")  //设置登录页面
                .loginProcessingUrl("/authentication/form") //遇到该请求则进行user password认证
                .successHandler(imoocAuthenticationSuccessHandler)  //成功后 使用我们自己的处理器处理
                .failureHandler(imoocAuthenticationFailureHandler)  //设置失败处理器
            .and()
                .authorizeRequests()   //授权
                //当访问这个路径的时候不需要身份认证 除了它其他的是需要身份认证
                .antMatchers("/authentication/require", securityProperties.getBrowser().getLoginPage()).permitAll()
                .anyRequest()    //任何请求
                .authenticated()   //都需要认证
            .and()
                .csrf().disable();

    }
}

```

测试如果输入index.html路径，会先被拦截让登陆。若用户名密码正确而且返回类型为REDIRECT时，会自动跳转到index.html页面

### 图片验证码

![2019-03-20_115554](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/docs/pictures/2019-03-20_115554.png)

![2019-03-20_115722](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/docs/pictures/2019-03-20_115722.png)

![2019-03-20_122943](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/docs/pictures/2019-03-20_122943.png)

验证码实体类

```java
@Data
@AllArgsConstructor
@NoArgsConstructor
public class ImageCode {

    private BufferedImage image;

    private String code;  //随机数存到session中

    private LocalDateTime expireTime;  //有效时间

    public ImageCode (BufferedImage image,String code,
                      int expireIn) {
        this.image=image;
        this.code=code;
        this.expireTime=LocalDateTime.now().plusSeconds(expireIn);
    }

    public boolean isExpried(){
        //如果 过期时间 在 当前日期 之前，则验证码过期
        return LocalDateTime.now().isAfter(expireTime);
    }
}

```

验证码Controller，此时即可显示验证码，但需要写过滤器验证

```java
@RestController
public class ValidateCodeController {

    public static final String SESSION_KEY = "SESSION_KEY_IMAGE_CODE";

    private SessionStrategy sessionStrategy=new HttpSessionSessionStrategy();

    @GetMapping("/code/image")
    public void createCode(HttpServletRequest request, HttpServletResponse response)throws Exception {
        ImageCode imageCode = createImageCode(request);
        //code放到sesison 第二步
        sessionStrategy.setAttribute(new ServletWebRequest(request), SESSION_KEY, imageCode);
        //将图片写到响应的接口中 第三步
        ImageIO.write(imageCode.getImage(), "JPEG", response.getOutputStream());
    }

    private ImageCode createImageCode(HttpServletRequest request) {
        //第一步 生成随机验证码 可以去网上搜
        int width=67;//宽和高
        int height=23;
        BufferedImage image = new BufferedImage(width,height,BufferedImage.TYPE_INT_BGR);

        Graphics g = image.getGraphics();

        Random random = new Random();

        g.setColor(getRandColor(200,250));
        g.fillRect(0, 0, width, height);
        g.setFont(new Font("Times New Roman",Font.ITALIC,20));
        g.setColor(getRandColor(160,200));
        for(int i=0;i<155;i++) {
            int x = random.nextInt(width);
            int y = random.nextInt(height);
            int xl =random.nextInt(12);
            int yl =random.nextInt(12);
            g.drawLine(x, y, x+xl, y+yl);
        }

        String sRand = "";
        for (int i = 0; i < 4; i++) {//数字验证码长度
            String rand = String.valueOf(random.nextInt(10));
            sRand +=rand;
            g.setColor(new Color(20 + random.nextInt(110),
                    20 + random.nextInt(110),20 + random.nextInt(110)));
            g.drawString(rand, 13*i+6, 16);
        }

        g.dispose();

        return new ImageCode(image,sRand,60);//有效期60秒
    }

    /**
     * 生成随机背景条纹
     */
    private Color getRandColor(int fc,int bc) {
        Random random = new Random();
        if (fc > 255) {
            fc = 255;
        }
        if (bc > 255) {
            bc = 255;
        }
        int r = fc + random.nextInt(bc - fc);
        int g = fc + random.nextInt(bc - fc);
        int b = fc + random.nextInt(bc - fc);
        return new Color(r,g,b);
    }
}
```

过滤器，自动注入AuthenticationFailureHandler，实际为`com.imooc.security.browser.authentication.ImoocAuthenticationFailureHandler`类，自定义了异常类`ValidateCodeException`，有任何逻辑不对就抛出异常，再让`ImoocAuthenticationFailureHandler`处理。否则进行下一个过滤器

```java
@Data
@Slf4j
public class ValidateCodeFilter extends OncePerRequestFilter {

    @Autowired
    private AuthenticationFailureHandler authenticationFailureHandler;

    private SessionStrategy sessionStrategy = new HttpSessionSessionStrategy();

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {
        //主干逻辑
        //必须是个请求路径并且必须是post请求
        if (StringUtils.equals("/authentication/form", request.getRequestURI()) && StringUtils.equalsIgnoreCase(request.getMethod(), "post")) {
            try {
                //校验逻辑
                validate(new ServletWebRequest(request));
            }catch (ValidateCodeException e){
                log.info("ValidateCodeFilter==>doFilterInternal==>authenticationFailureHandler.getClass().getName()== "+authenticationFailureHandler.getClass().getName());
                authenticationFailureHandler.onAuthenticationFailure(request, response, e);
                return;
            }
        }

        filterChain.doFilter(request, response);
    }

    //校验逻辑
    private void validate(ServletWebRequest request) throws ServletRequestBindingException {

        ImageCode codeInSession = (ImageCode)sessionStrategy.getAttribute(request,
                ValidateCodeController.SESSION_KEY);

        String codeInRequest = ServletRequestUtils.getStringParameter(request.getRequest(), "imageCode");

        if (StringUtils.isBlank(codeInRequest)) {
            throw new ValidateCodeException("验证码的值不能为空,the code must be not null");
        }
        if (codeInSession == null) {
            throw new ValidateCodeException("验证码不存在");
        }
        if (codeInSession.isExpried()) {
            sessionStrategy.removeAttribute(request, ValidateCodeController.SESSION_KEY);
            throw new ValidateCodeException("验证码已过期");
        }
        if (!StringUtils.equals(codeInSession.getCode(), codeInRequest)) {
            throw new ValidateCodeException("验证码不匹配");
        }

        sessionStrategy.removeAttribute(request, ValidateCodeController.SESSION_KEY);
    }
}

```

```java
public class ValidateCodeException extends AuthenticationException {


    /**
     *
     */
    private static final long serialVersionUID = -7285211528095468156L;

    public ValidateCodeException(String msg) {
        super(msg);
    }
}
```

最后配置信息要添加上

```java
@Configuration
@Slf4j
public class BrowserSecurityConfig extends WebSecurityConfigurerAdapter {

    @Autowired
    private SecurityProperties securityProperties;

    //让系统使用我们自定义 而不是系统默认的配置
    @Autowired
    private ImoocAuthenticationSuccessHandler imoocAuthenticationSuccessHandler;

    @Autowired
    private ImoocAuthenticationFailureHandler imoocAuthenticationFailureHandler;

    //注入密码加密的类
    @Bean
    public PasswordEncoder passwordEncoder() {
        //这里如果是自己编写的加密 则调用自己的类 方法有编码和解码验证方法
        return new SCryptPasswordEncoder();
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {

        ValidateCodeFilter validateCodeFilter = new ValidateCodeFilter();
        validateCodeFilter.setAuthenticationFailureHandler(imoocAuthenticationFailureHandler);

        //在UsernamePasswordAuthenticationFilter 过滤器前 加一个过滤器 来搞验证码
        http.addFilterBefore(validateCodeFilter, UsernamePasswordAuthenticationFilter.class)
                .formLogin() //认证
            .loginPage("/authentication/require")  //设置登录页面
                .loginProcessingUrl("/authentication/form") //遇到该请求则进行user password认证
                .successHandler(imoocAuthenticationSuccessHandler)  //成功后 使用我们自己的处理器处理
                .failureHandler(imoocAuthenticationFailureHandler)  //设置失败处理器
            .and()
                .authorizeRequests()   //授权
                //当访问这个路径的时候不需要身份认证 除了它其他的是需要身份认证
                .antMatchers("/authentication/require"
                        , securityProperties.getBrowser().getLoginPage()
                        , "/code/image").permitAll()
                .anyRequest()    //任何请求
                .authenticated()   //都需要认证
            .and()
                .csrf().disable();

    }
}
```

###  图片验证码重构

![2019-03-20_165036](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/docs/pictures/2019-03-20_165036.png)

![2019-03-20_165120](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/docs/pictures/2019-03-20_165120.png)

验证码实体类

```java
@Data
public class ImageCodeProperties {

    private int width = 67;
    private int height = 23;
    private int length = 4;    //验证码长度
    private int expireIn = 60;   //失效时间

    private String url;
}
```

```java
@Data
public class ValidateCodeProperties {

    private ImageCodeProperties image = new ImageCodeProperties();

}
```

```java
//意思是这个类会读取配置文件中所有以imooc.security开头的配置项
//其中browser的配置项会读取到BrowserProperties的对象中去
@ConfigurationProperties(prefix = "imooc.security")
@Data
public class SecurityProperties {

    private BrowserProperties browser = new BrowserProperties();

    private ValidateCodeProperties code = new ValidateCodeProperties();
}
```

这是在配置拦截的路径接口

```java
/**
 * 校验验证码的过滤器
 * @Description
 * @auther 断弯刀
 * @create 2019-03-20 14:35
 */
@Data
@Slf4j
//InitializingBean在其他参数都组装完毕以后，初始化urls的值
public class ValidateCodeFilter extends OncePerRequestFilter implements InitializingBean {

    /**
     * 验证码校验失败处理器
     */
    @Autowired
    private AuthenticationFailureHandler authenticationFailureHandler;

    private SessionStrategy sessionStrategy = new HttpSessionSessionStrategy();

    /**
     * 存放所有需要校验验证码的url
     */
    private Set<String> urls = new HashSet<>();

    /**
     * 系统配置信息
     */
    @Autowired
    private SecurityProperties securityProperties;

    /**
     * 验证请求url与配置的url是否匹配的工具类
     */
    private AntPathMatcher antPathMatcher = new AntPathMatcher();

    /**
     * 初始化要拦截的url配置信息
     * @throws ServletException
     */
    @Override
    public void afterPropertiesSet() throws ServletException {
        String[] configUrls = StringUtils.splitByWholeSeparator(securityProperties.getCode().getImage().getUrl(), ",");
        for (String url : configUrls) {
            urls.add(url);
        }
        urls.add("/authentication/form");
    }

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {

        boolean action = false;
        log.info("urls的长度是:" + urls.size() + "它们是：" + urls.toString());
        log.info("requestUri是:" + request.getRequestURI());
        for (String url : urls) {
            if (antPathMatcher.match(url, request.getRequestURI())) {
                action = true;
            }
        }
        if (action) {
            try {
                //校验逻辑
                validate(new ServletWebRequest(request));
            }catch (ValidateCodeException e){
                authenticationFailureHandler.onAuthenticationFailure(request, response, e);
                return;
            }
        }
        filterChain.doFilter(request, response);
    }

    //校验逻辑
    private void validate(ServletWebRequest request) throws ServletRequestBindingException {

        ImageCode codeInSession = (ImageCode)sessionStrategy.getAttribute(request,
                ValidateCodeController.SESSION_KEY);

        String codeInRequest = ServletRequestUtils.getStringParameter(request.getRequest(), "imageCode");

        if (StringUtils.isBlank(codeInRequest)) {
            throw new ValidateCodeException("验证码的值不能为空,the code must be not null");
        }
        if (codeInSession == null) {
            throw new ValidateCodeException("验证码不存在");
        }
        if (codeInSession.isExpried()) {
            sessionStrategy.removeAttribute(request, ValidateCodeController.SESSION_KEY);
            throw new ValidateCodeException("验证码已过期");
        }
        if (!StringUtils.equals(codeInSession.getCode(), codeInRequest)) {
            throw new ValidateCodeException("验证码不匹配");
        }

        sessionStrategy.removeAttribute(request, ValidateCodeController.SESSION_KEY);
    }
}

```
配置进去

```java
@Configuration
@Slf4j
public class BrowserSecurityConfig extends WebSecurityConfigurerAdapter {

    @Autowired
    private SecurityProperties securityProperties;

    //让系统使用我们自定义 而不是系统默认的配置
    @Autowired
    private ImoocAuthenticationSuccessHandler imoocAuthenticationSuccessHandler;

    @Autowired
    private ImoocAuthenticationFailureHandler imoocAuthenticationFailureHandler;

    //注入密码加密的类
    @Bean
    public PasswordEncoder passwordEncoder() {
        //这里如果是自己编写的加密 则调用自己的类 方法有编码和解码验证方法
        return new SCryptPasswordEncoder();
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {

        ValidateCodeFilter validateCodeFilter = new ValidateCodeFilter();
        validateCodeFilter.setAuthenticationFailureHandler(imoocAuthenticationFailureHandler);
        validateCodeFilter.setSecurityProperties(securityProperties);
        validateCodeFilter.afterPropertiesSet();

        //在UsernamePasswordAuthenticationFilter 过滤器前 加一个过滤器 来搞验证码
        http.addFilterBefore(validateCodeFilter, UsernamePasswordAuthenticationFilter.class)
                .formLogin() //认证
            .loginPage("/authentication/require")  //设置登录页面
                .loginProcessingUrl("/authentication/form") //遇到该请求则进行user password认证
                .successHandler(imoocAuthenticationSuccessHandler)  //成功后 使用我们自己的处理器处理
                .failureHandler(imoocAuthenticationFailureHandler)  //设置失败处理器
            .and()
                .authorizeRequests()   //授权
                //当访问这个路径的时候不需要身份认证 除了它其他的是需要身份认证
                .antMatchers("/authentication/require"
                        , securityProperties.getBrowser().getLoginPage()
                        , "/code/image").permitAll()
                .anyRequest()    //任何请求
                .authenticated()   //都需要认证
            .and()
                .csrf().disable();
    }
}
```

验证码信息封装类，自己封装了个`isExpried()`方法

```java
@Data
@AllArgsConstructor
public class ValidateCode implements Serializable {

    /**
     *
     */
    private static final long serialVersionUID = 1588203828504660915L;

    private String code;   //随机数存到session中

    private LocalDateTime expireTime;   //有效时间

    public ValidateCode(String code, int expireIn){
        this.code = code;
        this.expireTime = LocalDateTime.now().plusSeconds(expireIn);
    }

    public boolean isExpried() {
        return LocalDateTime.now().isAfter(expireTime);
    }
}
```

图片验证码具体类继承`ValidateCode`，其实就是多了一个`BufferedImage`对象

```java
@Data
public class ImageCode extends ValidateCode {

    private BufferedImage image;

    public ImageCode(BufferedImage image, String code, int expireIn){
        super(code, expireIn);
        this.image = image;
    }

    public ImageCode(BufferedImage image, String code, LocalDateTime expireTime){
        super(code, expireTime);
        this.image = image;
    }
}
```

校验码生成器

```java
public interface ValidateCodeGenerator {

    /**
     * 生成校验码
     * @param request
     * @return
     */
    ValidateCode generate(ServletWebRequest request);
}
```

默认的图片验证码生成器

```java
@Data
public class ImageCodeGenerator implements ValidateCodeGenerator {

    /**
     * 系统配置
     */
    @Autowired
    private SecurityProperties securityProperties;

    @Override
    public ImageCode generate(ServletWebRequest request) {
        //生成随机验证码
        int width = ServletRequestUtils.getIntParameter(request.getRequest(), "width", securityProperties.getCode().getImage().getWidth());//宽和高
        int height = ServletRequestUtils.getIntParameter(request.getRequest(), "height", securityProperties.getCode().getImage().getHeight());
        BufferedImage image = new BufferedImage(width,height,BufferedImage.TYPE_INT_BGR);

        Graphics g = image.getGraphics();

        Random random = new Random();

        g.setColor(getRandColor(200,250));
        g.fillRect(0, 0, width, height);
        g.setFont(new Font("Times New Roman",Font.ITALIC,20));
        g.setColor(getRandColor(160,200));
        for(int i=0;i<155;i++) {
            int x = random.nextInt(width);
            int y = random.nextInt(height);
            int xl =random.nextInt(12);
            int yl =random.nextInt(12);
            g.drawLine(x, y, x+xl, y+yl);
        }

        String sRand = "";
        for (int i = 0; i < securityProperties.getCode().getImage().getLength(); i++) {   //数字验证码长度
            String rand = String.valueOf(random.nextInt(10));
            sRand +=rand;
            g.setColor(new Color(20 + random.nextInt(110),
                    20 + random.nextInt(110),20 + random.nextInt(110)));
            g.drawString(rand, 13*i+6, 16);
        }

        g.dispose();

        return new ImageCode(image,sRand,60);//有效期60秒
    }

    /**
     * 生成随机背景条纹
     */
    private Color getRandColor(int fc,int bc) {
        Random random = new Random();
        if (fc > 255) {
            fc = 255;
        }
        if (bc > 255) {
            bc = 255;
        }
        int r = fc + random.nextInt(bc - fc);
        int g = fc + random.nextInt(bc - fc);
        int b = fc + random.nextInt(bc - fc);
        return new Color(r,g,b);
    }
}
```

验证码相关的扩展点配置

```java
@Configuration
public class ValidateCodeBeanConfig {

    @Autowired
    private SecurityProperties securityProperties;

    /**
     * 在触发 ValidateCodeGenerator 之前会检测有没有imageCodeGenerator这个bean。
     * 如果能找到，则不会用ValidateCodeGenerator，而是用找到的imageCodeGenerator
     * @return
     */
    @Bean
    @ConditionalOnMissingBean(name = "imageCodeGenerator")
    public ValidateCodeGenerator imageCodeGenerator() {
        ImageCodeGenerator codeGenerator = new ImageCodeGenerator();
        codeGenerator.setSecurityProperties(securityProperties);
        return codeGenerator;
    }
}
```

生成校验码的请求处理器

```java
@RestController
public class ValidateCodeController {

    public static final String SESSION_KEY = "SESSION_KEY_IMAGE_CODE";

    private SessionStrategy sessionStrategy=new HttpSessionSessionStrategy();

    @Autowired
    private ValidateCodeGenerator imageCodeGenerator;

    /**
     * 创建验证码
     * @param request
     * @param response
     * @throws Exception
     */
    @GetMapping("/code/image")
    public void createCode(HttpServletRequest request, HttpServletResponse response)throws Exception {
        ImageCode imageCode = (ImageCode)imageCodeGenerator.generate(new ServletWebRequest(request));
        //code放到sesison 第二步
        sessionStrategy.setAttribute(new ServletWebRequest(request), SESSION_KEY, imageCode);
        //将图片写到响应的接口中 第三步
        ImageIO.write(imageCode.getImage(), "JPEG", response.getOutputStream());
    }

}
```

测试DemoImageCodeGenerator

```java
//@Component("imageCodeGenerator")
public class DemoImageCodeGenerator implements ValidateCodeGenerator {

    @Override
    public ValidateCode generate(ServletWebRequest request) {
        System.out.println("更高级的图形验证码生成代码");
        return null;
    }
}
```

<table><tr><td bgcolor=orange>验证测试</td></tr></table>

#### 验证码基本参数可配置

浏览器进入index.html，被拦截，如图所示

![2019-03-21_075417](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/docs/pictures/2019-03-21_075417.png)

验证码位数为6，说明demo模块中的application.properties中的配置生效。demo模块覆盖了core模块`ImageCodeProperties`默认的值

```properties
imooc.security.code.image.length = 6
imooc.security.code.image.width = 100
imooc.security.code.image.url = /user,/user/*
```

验证码图片长度明显太长：    browser模块中imooc-signIn.html部分

```html
<tr>
				<td>图形验证码:</td>
				<td>
					<input type="text" name="imageCode">
					<img src="/code/image?width=200">
				</td>
			</tr>
```

说明`width=200 `覆盖了demo模块中的`imooc.security.code.image.width = 100`的值

#### 验证码拦截的接口可配置

​	`ValidateCodeFilter`中的`urls`存放所有需要校验验证码的url。` urls.add("/authentication/form");`是登录表单的提交路径，当然需要添加。

```java
String[] configUrls = StringUtils.splitByWholeSeparator(securityProperties.getCode().getImage().getUrl(), ",");
        for (String url : configUrls) {
            urls.add(url);
        }
```

以上代码是获取手动配置的需要拦截的路径

验证：登录页面什么都不填写直接点击登录会被拦截，说明`urls.add("/authentication/form");`生效，如图所示

![2019-03-21_082145](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/docs/pictures/2019-03-21_082145.png)

http://localhost:8080/user 路径会被拦截，说明自己配置的路径被拦截生效。如图所示

![2019-03-21_082226](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/docs/pictures/2019-03-21_082226.png)

#### 验证码的生成逻辑可配置

直接测试即可将`DemoImageCodeGenerator`类上添加注解`@Component("imageCodeGenerator")`

进入index.html，让其生成验证码。结果图片生成失败，如图所示

![2019-03-21_083904](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/docs/pictures/2019-03-21_083904.png)

控制台信息，报空指针异常，因为返回为null

![2019-03-21_083816](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/docs/pictures/2019-03-21_083816.png)